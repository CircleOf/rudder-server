// Code generated by ObjectBox; DO NOT EDIT.
// Learn more about defining entities and generating this file - visit https://golang.objectbox.io/entity-annotations

package objectdb

import (
	"errors"
	"github.com/google/flatbuffers/go"
	"github.com/objectbox/objectbox-go/objectbox"
	"github.com/objectbox/objectbox-go/objectbox/fbutils"
)

type sourceID_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var SourceIDBinding = sourceID_EntityInfo{
	Entity: objectbox.Entity{
		Id: 1,
	},
	Uid: 2869925747500390059,
}

// SourceID_ contains type-based Property helpers to facilitate some common operations such as Queries.
var SourceID_ = struct {
	Name *objectbox.PropertyString
	Id   *objectbox.PropertyUint64
}{
	Name: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &SourceIDBinding.Entity,
		},
	},
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &SourceIDBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (sourceID_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (sourceID_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("SourceID", 1, 2869925747500390059)
	model.Property("Name", 9, 1, 8822926318559914003)
	model.PropertyFlags(2080)
	model.PropertyIndex(1, 5857677081866681575)
	model.Property("Id", 6, 2, 8294440399638864848)
	model.PropertyFlags(1)
	model.EntityLastPropertyId(2, 8294440399638864848)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (sourceID_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*SourceID).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (sourceID_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*SourceID).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (sourceID_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (sourceID_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*SourceID)
	var offsetName = fbutils.CreateStringOffset(fbb, obj.Name)

	// build the FlatBuffers object
	fbb.StartObject(2)
	fbutils.SetUOffsetTSlot(fbb, 0, offsetName)
	fbutils.SetUint64Slot(fbb, 1, id)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (sourceID_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'SourceID' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(6, 0)

	return &SourceID{
		Name: fbutils.GetStringSlot(table, 4),
		Id:   propId,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (sourceID_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*SourceID, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (sourceID_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*SourceID), nil)
	}
	return append(slice.([]*SourceID), object.(*SourceID))
}

// Box provides CRUD access to SourceID objects
type SourceIDBox struct {
	*objectbox.Box
}

// BoxForSourceID opens a box of SourceID objects
func BoxForSourceID(ob *objectbox.ObjectBox) *SourceIDBox {
	return &SourceIDBox{
		Box: ob.InternalBox(1),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceID.Id property on the passed object will be assigned the new ID as well.
func (box *SourceIDBox) Put(object *SourceID) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceID.Id property on the passed object will be assigned the new ID as well.
func (box *SourceIDBox) Insert(object *SourceID) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *SourceIDBox) Update(object *SourceID) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *SourceIDBox) PutAsync(object *SourceID) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the SourceID.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the SourceID.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *SourceIDBox) PutMany(objects []*SourceID) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *SourceIDBox) Get(id uint64) (*SourceID, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*SourceID), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *SourceIDBox) GetMany(ids ...uint64) ([]*SourceID, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceID), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *SourceIDBox) GetManyExisting(ids ...uint64) ([]*SourceID, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceID), nil
}

// GetAll reads all stored objects
func (box *SourceIDBox) GetAll() ([]*SourceID, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceID), nil
}

// Remove deletes a single object
func (box *SourceIDBox) Remove(object *SourceID) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *SourceIDBox) RemoveMany(objects ...*SourceID) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the SourceID_ struct to create conditions.
// Keep the *SourceIDQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *SourceIDBox) Query(conditions ...objectbox.Condition) *SourceIDQuery {
	return &SourceIDQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the SourceID_ struct to create conditions.
// Keep the *SourceIDQuery if you intend to execute the query multiple times.
func (box *SourceIDBox) QueryOrError(conditions ...objectbox.Condition) (*SourceIDQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &SourceIDQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See SourceIDAsyncBox for more information.
func (box *SourceIDBox) Async() *SourceIDAsyncBox {
	return &SourceIDAsyncBox{AsyncBox: box.Box.Async()}
}

// SourceIDAsyncBox provides asynchronous operations on SourceID objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type SourceIDAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForSourceID creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use SourceIDBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForSourceID(ob *objectbox.ObjectBox, timeoutMs uint64) *SourceIDAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 1, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 1: %s" + err.Error())
	}
	return &SourceIDAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *SourceIDAsyncBox) Put(object *SourceID) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *SourceIDAsyncBox) Insert(object *SourceID) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *SourceIDAsyncBox) Update(object *SourceID) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *SourceIDAsyncBox) Remove(object *SourceID) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all SourceID which Id is either 42 or 47:
// 		box.Query(SourceID_.Id.In(42, 47)).Find()
type SourceIDQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *SourceIDQuery) Find() ([]*SourceID, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceID), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *SourceIDQuery) Offset(offset uint64) *SourceIDQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *SourceIDQuery) Limit(limit uint64) *SourceIDQuery {
	query.Query.Limit(limit)
	return query
}

type destinationID_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var DestinationIDBinding = destinationID_EntityInfo{
	Entity: objectbox.Entity{
		Id: 2,
	},
	Uid: 4423711829853508685,
}

// DestinationID_ contains type-based Property helpers to facilitate some common operations such as Queries.
var DestinationID_ = struct {
	Name *objectbox.PropertyString
	Id   *objectbox.PropertyUint64
}{
	Name: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &DestinationIDBinding.Entity,
		},
	},
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &DestinationIDBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (destinationID_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (destinationID_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("DestinationID", 2, 4423711829853508685)
	model.Property("Name", 9, 1, 3179530378592174960)
	model.PropertyFlags(2080)
	model.PropertyIndex(2, 5778610862127550351)
	model.Property("Id", 6, 2, 6534063759529313207)
	model.PropertyFlags(1)
	model.EntityLastPropertyId(2, 6534063759529313207)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (destinationID_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*DestinationID).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (destinationID_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*DestinationID).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (destinationID_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (destinationID_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*DestinationID)
	var offsetName = fbutils.CreateStringOffset(fbb, obj.Name)

	// build the FlatBuffers object
	fbb.StartObject(2)
	fbutils.SetUOffsetTSlot(fbb, 0, offsetName)
	fbutils.SetUint64Slot(fbb, 1, id)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (destinationID_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'DestinationID' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(6, 0)

	return &DestinationID{
		Name: fbutils.GetStringSlot(table, 4),
		Id:   propId,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (destinationID_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*DestinationID, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (destinationID_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*DestinationID), nil)
	}
	return append(slice.([]*DestinationID), object.(*DestinationID))
}

// Box provides CRUD access to DestinationID objects
type DestinationIDBox struct {
	*objectbox.Box
}

// BoxForDestinationID opens a box of DestinationID objects
func BoxForDestinationID(ob *objectbox.ObjectBox) *DestinationIDBox {
	return &DestinationIDBox{
		Box: ob.InternalBox(2),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the DestinationID.Id property on the passed object will be assigned the new ID as well.
func (box *DestinationIDBox) Put(object *DestinationID) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the DestinationID.Id property on the passed object will be assigned the new ID as well.
func (box *DestinationIDBox) Insert(object *DestinationID) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *DestinationIDBox) Update(object *DestinationID) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *DestinationIDBox) PutAsync(object *DestinationID) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the DestinationID.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the DestinationID.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *DestinationIDBox) PutMany(objects []*DestinationID) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *DestinationIDBox) Get(id uint64) (*DestinationID, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*DestinationID), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *DestinationIDBox) GetMany(ids ...uint64) ([]*DestinationID, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*DestinationID), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *DestinationIDBox) GetManyExisting(ids ...uint64) ([]*DestinationID, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*DestinationID), nil
}

// GetAll reads all stored objects
func (box *DestinationIDBox) GetAll() ([]*DestinationID, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*DestinationID), nil
}

// Remove deletes a single object
func (box *DestinationIDBox) Remove(object *DestinationID) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *DestinationIDBox) RemoveMany(objects ...*DestinationID) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the DestinationID_ struct to create conditions.
// Keep the *DestinationIDQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *DestinationIDBox) Query(conditions ...objectbox.Condition) *DestinationIDQuery {
	return &DestinationIDQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the DestinationID_ struct to create conditions.
// Keep the *DestinationIDQuery if you intend to execute the query multiple times.
func (box *DestinationIDBox) QueryOrError(conditions ...objectbox.Condition) (*DestinationIDQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &DestinationIDQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See DestinationIDAsyncBox for more information.
func (box *DestinationIDBox) Async() *DestinationIDAsyncBox {
	return &DestinationIDAsyncBox{AsyncBox: box.Box.Async()}
}

// DestinationIDAsyncBox provides asynchronous operations on DestinationID objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type DestinationIDAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForDestinationID creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use DestinationIDBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForDestinationID(ob *objectbox.ObjectBox, timeoutMs uint64) *DestinationIDAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 2, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 2: %s" + err.Error())
	}
	return &DestinationIDAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *DestinationIDAsyncBox) Put(object *DestinationID) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *DestinationIDAsyncBox) Insert(object *DestinationID) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *DestinationIDAsyncBox) Update(object *DestinationID) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *DestinationIDAsyncBox) Remove(object *DestinationID) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all DestinationID which Id is either 42 or 47:
// 		box.Query(DestinationID_.Id.In(42, 47)).Find()
type DestinationIDQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *DestinationIDQuery) Find() ([]*DestinationID, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*DestinationID), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *DestinationIDQuery) Offset(offset uint64) *DestinationIDQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *DestinationIDQuery) Limit(limit uint64) *DestinationIDQuery {
	query.Query.Limit(limit)
	return query
}

type sourceBatchID_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var SourceBatchIDBinding = sourceBatchID_EntityInfo{
	Entity: objectbox.Entity{
		Id: 3,
	},
	Uid: 3597879070429767399,
}

// SourceBatchID_ contains type-based Property helpers to facilitate some common operations such as Queries.
var SourceBatchID_ = struct {
	Name *objectbox.PropertyString
	Id   *objectbox.PropertyUint64
}{
	Name: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &SourceBatchIDBinding.Entity,
		},
	},
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &SourceBatchIDBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (sourceBatchID_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (sourceBatchID_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("SourceBatchID", 3, 3597879070429767399)
	model.Property("Name", 9, 1, 4555383759773553284)
	model.PropertyFlags(2080)
	model.PropertyIndex(3, 5006739390375501261)
	model.Property("Id", 6, 2, 5675185202085856417)
	model.PropertyFlags(1)
	model.EntityLastPropertyId(2, 5675185202085856417)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (sourceBatchID_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*SourceBatchID).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (sourceBatchID_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*SourceBatchID).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (sourceBatchID_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (sourceBatchID_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*SourceBatchID)
	var offsetName = fbutils.CreateStringOffset(fbb, obj.Name)

	// build the FlatBuffers object
	fbb.StartObject(2)
	fbutils.SetUOffsetTSlot(fbb, 0, offsetName)
	fbutils.SetUint64Slot(fbb, 1, id)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (sourceBatchID_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'SourceBatchID' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(6, 0)

	return &SourceBatchID{
		Name: fbutils.GetStringSlot(table, 4),
		Id:   propId,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (sourceBatchID_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*SourceBatchID, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (sourceBatchID_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*SourceBatchID), nil)
	}
	return append(slice.([]*SourceBatchID), object.(*SourceBatchID))
}

// Box provides CRUD access to SourceBatchID objects
type SourceBatchIDBox struct {
	*objectbox.Box
}

// BoxForSourceBatchID opens a box of SourceBatchID objects
func BoxForSourceBatchID(ob *objectbox.ObjectBox) *SourceBatchIDBox {
	return &SourceBatchIDBox{
		Box: ob.InternalBox(3),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceBatchID.Id property on the passed object will be assigned the new ID as well.
func (box *SourceBatchIDBox) Put(object *SourceBatchID) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceBatchID.Id property on the passed object will be assigned the new ID as well.
func (box *SourceBatchIDBox) Insert(object *SourceBatchID) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *SourceBatchIDBox) Update(object *SourceBatchID) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *SourceBatchIDBox) PutAsync(object *SourceBatchID) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the SourceBatchID.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the SourceBatchID.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *SourceBatchIDBox) PutMany(objects []*SourceBatchID) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *SourceBatchIDBox) Get(id uint64) (*SourceBatchID, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*SourceBatchID), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *SourceBatchIDBox) GetMany(ids ...uint64) ([]*SourceBatchID, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceBatchID), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *SourceBatchIDBox) GetManyExisting(ids ...uint64) ([]*SourceBatchID, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceBatchID), nil
}

// GetAll reads all stored objects
func (box *SourceBatchIDBox) GetAll() ([]*SourceBatchID, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceBatchID), nil
}

// Remove deletes a single object
func (box *SourceBatchIDBox) Remove(object *SourceBatchID) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *SourceBatchIDBox) RemoveMany(objects ...*SourceBatchID) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the SourceBatchID_ struct to create conditions.
// Keep the *SourceBatchIDQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *SourceBatchIDBox) Query(conditions ...objectbox.Condition) *SourceBatchIDQuery {
	return &SourceBatchIDQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the SourceBatchID_ struct to create conditions.
// Keep the *SourceBatchIDQuery if you intend to execute the query multiple times.
func (box *SourceBatchIDBox) QueryOrError(conditions ...objectbox.Condition) (*SourceBatchIDQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &SourceBatchIDQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See SourceBatchIDAsyncBox for more information.
func (box *SourceBatchIDBox) Async() *SourceBatchIDAsyncBox {
	return &SourceBatchIDAsyncBox{AsyncBox: box.Box.Async()}
}

// SourceBatchIDAsyncBox provides asynchronous operations on SourceBatchID objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type SourceBatchIDAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForSourceBatchID creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use SourceBatchIDBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForSourceBatchID(ob *objectbox.ObjectBox, timeoutMs uint64) *SourceBatchIDAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 3, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 3: %s" + err.Error())
	}
	return &SourceBatchIDAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *SourceBatchIDAsyncBox) Put(object *SourceBatchID) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *SourceBatchIDAsyncBox) Insert(object *SourceBatchID) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *SourceBatchIDAsyncBox) Update(object *SourceBatchID) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *SourceBatchIDAsyncBox) Remove(object *SourceBatchID) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all SourceBatchID which Id is either 42 or 47:
// 		box.Query(SourceBatchID_.Id.In(42, 47)).Find()
type SourceBatchIDQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *SourceBatchIDQuery) Find() ([]*SourceBatchID, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceBatchID), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *SourceBatchIDQuery) Offset(offset uint64) *SourceBatchIDQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *SourceBatchIDQuery) Limit(limit uint64) *SourceBatchIDQuery {
	query.Query.Limit(limit)
	return query
}

type sourceTaskID_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var SourceTaskIDBinding = sourceTaskID_EntityInfo{
	Entity: objectbox.Entity{
		Id: 4,
	},
	Uid: 7486972548195051011,
}

// SourceTaskID_ contains type-based Property helpers to facilitate some common operations such as Queries.
var SourceTaskID_ = struct {
	Name *objectbox.PropertyString
	Id   *objectbox.PropertyUint64
}{
	Name: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &SourceTaskIDBinding.Entity,
		},
	},
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &SourceTaskIDBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (sourceTaskID_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (sourceTaskID_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("SourceTaskID", 4, 7486972548195051011)
	model.Property("Name", 9, 1, 6670263794285635977)
	model.PropertyFlags(2080)
	model.PropertyIndex(4, 1966803433132950248)
	model.Property("Id", 6, 2, 3770816779050135125)
	model.PropertyFlags(1)
	model.EntityLastPropertyId(2, 3770816779050135125)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (sourceTaskID_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*SourceTaskID).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (sourceTaskID_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*SourceTaskID).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (sourceTaskID_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (sourceTaskID_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*SourceTaskID)
	var offsetName = fbutils.CreateStringOffset(fbb, obj.Name)

	// build the FlatBuffers object
	fbb.StartObject(2)
	fbutils.SetUOffsetTSlot(fbb, 0, offsetName)
	fbutils.SetUint64Slot(fbb, 1, id)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (sourceTaskID_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'SourceTaskID' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(6, 0)

	return &SourceTaskID{
		Name: fbutils.GetStringSlot(table, 4),
		Id:   propId,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (sourceTaskID_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*SourceTaskID, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (sourceTaskID_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*SourceTaskID), nil)
	}
	return append(slice.([]*SourceTaskID), object.(*SourceTaskID))
}

// Box provides CRUD access to SourceTaskID objects
type SourceTaskIDBox struct {
	*objectbox.Box
}

// BoxForSourceTaskID opens a box of SourceTaskID objects
func BoxForSourceTaskID(ob *objectbox.ObjectBox) *SourceTaskIDBox {
	return &SourceTaskIDBox{
		Box: ob.InternalBox(4),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceTaskID.Id property on the passed object will be assigned the new ID as well.
func (box *SourceTaskIDBox) Put(object *SourceTaskID) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceTaskID.Id property on the passed object will be assigned the new ID as well.
func (box *SourceTaskIDBox) Insert(object *SourceTaskID) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *SourceTaskIDBox) Update(object *SourceTaskID) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *SourceTaskIDBox) PutAsync(object *SourceTaskID) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the SourceTaskID.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the SourceTaskID.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *SourceTaskIDBox) PutMany(objects []*SourceTaskID) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *SourceTaskIDBox) Get(id uint64) (*SourceTaskID, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*SourceTaskID), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *SourceTaskIDBox) GetMany(ids ...uint64) ([]*SourceTaskID, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceTaskID), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *SourceTaskIDBox) GetManyExisting(ids ...uint64) ([]*SourceTaskID, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceTaskID), nil
}

// GetAll reads all stored objects
func (box *SourceTaskIDBox) GetAll() ([]*SourceTaskID, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceTaskID), nil
}

// Remove deletes a single object
func (box *SourceTaskIDBox) Remove(object *SourceTaskID) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *SourceTaskIDBox) RemoveMany(objects ...*SourceTaskID) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the SourceTaskID_ struct to create conditions.
// Keep the *SourceTaskIDQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *SourceTaskIDBox) Query(conditions ...objectbox.Condition) *SourceTaskIDQuery {
	return &SourceTaskIDQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the SourceTaskID_ struct to create conditions.
// Keep the *SourceTaskIDQuery if you intend to execute the query multiple times.
func (box *SourceTaskIDBox) QueryOrError(conditions ...objectbox.Condition) (*SourceTaskIDQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &SourceTaskIDQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See SourceTaskIDAsyncBox for more information.
func (box *SourceTaskIDBox) Async() *SourceTaskIDAsyncBox {
	return &SourceTaskIDAsyncBox{AsyncBox: box.Box.Async()}
}

// SourceTaskIDAsyncBox provides asynchronous operations on SourceTaskID objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type SourceTaskIDAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForSourceTaskID creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use SourceTaskIDBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForSourceTaskID(ob *objectbox.ObjectBox, timeoutMs uint64) *SourceTaskIDAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 4, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 4: %s" + err.Error())
	}
	return &SourceTaskIDAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *SourceTaskIDAsyncBox) Put(object *SourceTaskID) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *SourceTaskIDAsyncBox) Insert(object *SourceTaskID) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *SourceTaskIDAsyncBox) Update(object *SourceTaskID) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *SourceTaskIDAsyncBox) Remove(object *SourceTaskID) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all SourceTaskID which Id is either 42 or 47:
// 		box.Query(SourceTaskID_.Id.In(42, 47)).Find()
type SourceTaskIDQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *SourceTaskIDQuery) Find() ([]*SourceTaskID, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceTaskID), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *SourceTaskIDQuery) Offset(offset uint64) *SourceTaskIDQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *SourceTaskIDQuery) Limit(limit uint64) *SourceTaskIDQuery {
	query.Query.Limit(limit)
	return query
}

type sourceTaskRunID_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var SourceTaskRunIDBinding = sourceTaskRunID_EntityInfo{
	Entity: objectbox.Entity{
		Id: 5,
	},
	Uid: 8932770196463363407,
}

// SourceTaskRunID_ contains type-based Property helpers to facilitate some common operations such as Queries.
var SourceTaskRunID_ = struct {
	Name *objectbox.PropertyString
	Id   *objectbox.PropertyUint64
}{
	Name: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &SourceTaskRunIDBinding.Entity,
		},
	},
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &SourceTaskRunIDBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (sourceTaskRunID_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (sourceTaskRunID_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("SourceTaskRunID", 5, 8932770196463363407)
	model.Property("Name", 9, 1, 1065717821419705975)
	model.PropertyFlags(2080)
	model.PropertyIndex(5, 4189380110654222829)
	model.Property("Id", 6, 2, 4523052647833371717)
	model.PropertyFlags(1)
	model.EntityLastPropertyId(2, 4523052647833371717)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (sourceTaskRunID_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*SourceTaskRunID).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (sourceTaskRunID_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*SourceTaskRunID).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (sourceTaskRunID_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (sourceTaskRunID_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*SourceTaskRunID)
	var offsetName = fbutils.CreateStringOffset(fbb, obj.Name)

	// build the FlatBuffers object
	fbb.StartObject(2)
	fbutils.SetUOffsetTSlot(fbb, 0, offsetName)
	fbutils.SetUint64Slot(fbb, 1, id)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (sourceTaskRunID_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'SourceTaskRunID' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(6, 0)

	return &SourceTaskRunID{
		Name: fbutils.GetStringSlot(table, 4),
		Id:   propId,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (sourceTaskRunID_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*SourceTaskRunID, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (sourceTaskRunID_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*SourceTaskRunID), nil)
	}
	return append(slice.([]*SourceTaskRunID), object.(*SourceTaskRunID))
}

// Box provides CRUD access to SourceTaskRunID objects
type SourceTaskRunIDBox struct {
	*objectbox.Box
}

// BoxForSourceTaskRunID opens a box of SourceTaskRunID objects
func BoxForSourceTaskRunID(ob *objectbox.ObjectBox) *SourceTaskRunIDBox {
	return &SourceTaskRunIDBox{
		Box: ob.InternalBox(5),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceTaskRunID.Id property on the passed object will be assigned the new ID as well.
func (box *SourceTaskRunIDBox) Put(object *SourceTaskRunID) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceTaskRunID.Id property on the passed object will be assigned the new ID as well.
func (box *SourceTaskRunIDBox) Insert(object *SourceTaskRunID) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *SourceTaskRunIDBox) Update(object *SourceTaskRunID) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *SourceTaskRunIDBox) PutAsync(object *SourceTaskRunID) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the SourceTaskRunID.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the SourceTaskRunID.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *SourceTaskRunIDBox) PutMany(objects []*SourceTaskRunID) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *SourceTaskRunIDBox) Get(id uint64) (*SourceTaskRunID, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*SourceTaskRunID), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *SourceTaskRunIDBox) GetMany(ids ...uint64) ([]*SourceTaskRunID, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceTaskRunID), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *SourceTaskRunIDBox) GetManyExisting(ids ...uint64) ([]*SourceTaskRunID, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceTaskRunID), nil
}

// GetAll reads all stored objects
func (box *SourceTaskRunIDBox) GetAll() ([]*SourceTaskRunID, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceTaskRunID), nil
}

// Remove deletes a single object
func (box *SourceTaskRunIDBox) Remove(object *SourceTaskRunID) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *SourceTaskRunIDBox) RemoveMany(objects ...*SourceTaskRunID) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the SourceTaskRunID_ struct to create conditions.
// Keep the *SourceTaskRunIDQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *SourceTaskRunIDBox) Query(conditions ...objectbox.Condition) *SourceTaskRunIDQuery {
	return &SourceTaskRunIDQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the SourceTaskRunID_ struct to create conditions.
// Keep the *SourceTaskRunIDQuery if you intend to execute the query multiple times.
func (box *SourceTaskRunIDBox) QueryOrError(conditions ...objectbox.Condition) (*SourceTaskRunIDQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &SourceTaskRunIDQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See SourceTaskRunIDAsyncBox for more information.
func (box *SourceTaskRunIDBox) Async() *SourceTaskRunIDAsyncBox {
	return &SourceTaskRunIDAsyncBox{AsyncBox: box.Box.Async()}
}

// SourceTaskRunIDAsyncBox provides asynchronous operations on SourceTaskRunID objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type SourceTaskRunIDAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForSourceTaskRunID creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use SourceTaskRunIDBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForSourceTaskRunID(ob *objectbox.ObjectBox, timeoutMs uint64) *SourceTaskRunIDAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 5, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 5: %s" + err.Error())
	}
	return &SourceTaskRunIDAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *SourceTaskRunIDAsyncBox) Put(object *SourceTaskRunID) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *SourceTaskRunIDAsyncBox) Insert(object *SourceTaskRunID) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *SourceTaskRunIDAsyncBox) Update(object *SourceTaskRunID) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *SourceTaskRunIDAsyncBox) Remove(object *SourceTaskRunID) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all SourceTaskRunID which Id is either 42 or 47:
// 		box.Query(SourceTaskRunID_.Id.In(42, 47)).Find()
type SourceTaskRunIDQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *SourceTaskRunIDQuery) Find() ([]*SourceTaskRunID, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceTaskRunID), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *SourceTaskRunIDQuery) Offset(offset uint64) *SourceTaskRunIDQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *SourceTaskRunIDQuery) Limit(limit uint64) *SourceTaskRunIDQuery {
	query.Query.Limit(limit)
	return query
}

type sourceJobID_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var SourceJobIDBinding = sourceJobID_EntityInfo{
	Entity: objectbox.Entity{
		Id: 6,
	},
	Uid: 4725412107568255400,
}

// SourceJobID_ contains type-based Property helpers to facilitate some common operations such as Queries.
var SourceJobID_ = struct {
	Name *objectbox.PropertyString
	Id   *objectbox.PropertyUint64
}{
	Name: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &SourceJobIDBinding.Entity,
		},
	},
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &SourceJobIDBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (sourceJobID_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (sourceJobID_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("SourceJobID", 6, 4725412107568255400)
	model.Property("Name", 9, 1, 5106424341227725479)
	model.PropertyFlags(2080)
	model.PropertyIndex(6, 5201644448580751275)
	model.Property("Id", 6, 2, 543088158877250910)
	model.PropertyFlags(1)
	model.EntityLastPropertyId(2, 543088158877250910)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (sourceJobID_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*SourceJobID).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (sourceJobID_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*SourceJobID).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (sourceJobID_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (sourceJobID_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*SourceJobID)
	var offsetName = fbutils.CreateStringOffset(fbb, obj.Name)

	// build the FlatBuffers object
	fbb.StartObject(2)
	fbutils.SetUOffsetTSlot(fbb, 0, offsetName)
	fbutils.SetUint64Slot(fbb, 1, id)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (sourceJobID_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'SourceJobID' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(6, 0)

	return &SourceJobID{
		Name: fbutils.GetStringSlot(table, 4),
		Id:   propId,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (sourceJobID_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*SourceJobID, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (sourceJobID_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*SourceJobID), nil)
	}
	return append(slice.([]*SourceJobID), object.(*SourceJobID))
}

// Box provides CRUD access to SourceJobID objects
type SourceJobIDBox struct {
	*objectbox.Box
}

// BoxForSourceJobID opens a box of SourceJobID objects
func BoxForSourceJobID(ob *objectbox.ObjectBox) *SourceJobIDBox {
	return &SourceJobIDBox{
		Box: ob.InternalBox(6),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceJobID.Id property on the passed object will be assigned the new ID as well.
func (box *SourceJobIDBox) Put(object *SourceJobID) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceJobID.Id property on the passed object will be assigned the new ID as well.
func (box *SourceJobIDBox) Insert(object *SourceJobID) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *SourceJobIDBox) Update(object *SourceJobID) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *SourceJobIDBox) PutAsync(object *SourceJobID) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the SourceJobID.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the SourceJobID.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *SourceJobIDBox) PutMany(objects []*SourceJobID) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *SourceJobIDBox) Get(id uint64) (*SourceJobID, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*SourceJobID), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *SourceJobIDBox) GetMany(ids ...uint64) ([]*SourceJobID, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceJobID), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *SourceJobIDBox) GetManyExisting(ids ...uint64) ([]*SourceJobID, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceJobID), nil
}

// GetAll reads all stored objects
func (box *SourceJobIDBox) GetAll() ([]*SourceJobID, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceJobID), nil
}

// Remove deletes a single object
func (box *SourceJobIDBox) Remove(object *SourceJobID) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *SourceJobIDBox) RemoveMany(objects ...*SourceJobID) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the SourceJobID_ struct to create conditions.
// Keep the *SourceJobIDQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *SourceJobIDBox) Query(conditions ...objectbox.Condition) *SourceJobIDQuery {
	return &SourceJobIDQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the SourceJobID_ struct to create conditions.
// Keep the *SourceJobIDQuery if you intend to execute the query multiple times.
func (box *SourceJobIDBox) QueryOrError(conditions ...objectbox.Condition) (*SourceJobIDQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &SourceJobIDQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See SourceJobIDAsyncBox for more information.
func (box *SourceJobIDBox) Async() *SourceJobIDAsyncBox {
	return &SourceJobIDAsyncBox{AsyncBox: box.Box.Async()}
}

// SourceJobIDAsyncBox provides asynchronous operations on SourceJobID objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type SourceJobIDAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForSourceJobID creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use SourceJobIDBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForSourceJobID(ob *objectbox.ObjectBox, timeoutMs uint64) *SourceJobIDAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 6, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 6: %s" + err.Error())
	}
	return &SourceJobIDAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *SourceJobIDAsyncBox) Put(object *SourceJobID) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *SourceJobIDAsyncBox) Insert(object *SourceJobID) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *SourceJobIDAsyncBox) Update(object *SourceJobID) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *SourceJobIDAsyncBox) Remove(object *SourceJobID) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all SourceJobID which Id is either 42 or 47:
// 		box.Query(SourceJobID_.Id.In(42, 47)).Find()
type SourceJobIDQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *SourceJobIDQuery) Find() ([]*SourceJobID, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceJobID), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *SourceJobIDQuery) Offset(offset uint64) *SourceJobIDQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *SourceJobIDQuery) Limit(limit uint64) *SourceJobIDQuery {
	query.Query.Limit(limit)
	return query
}

type sourceJobRunID_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var SourceJobRunIDBinding = sourceJobRunID_EntityInfo{
	Entity: objectbox.Entity{
		Id: 7,
	},
	Uid: 5613692470226056548,
}

// SourceJobRunID_ contains type-based Property helpers to facilitate some common operations such as Queries.
var SourceJobRunID_ = struct {
	Name *objectbox.PropertyString
	Id   *objectbox.PropertyUint64
}{
	Name: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &SourceJobRunIDBinding.Entity,
		},
	},
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &SourceJobRunIDBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (sourceJobRunID_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (sourceJobRunID_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("SourceJobRunID", 7, 5613692470226056548)
	model.Property("Name", 9, 1, 429910614972959229)
	model.PropertyFlags(2080)
	model.PropertyIndex(7, 468892721311029718)
	model.Property("Id", 6, 2, 4930178864712545365)
	model.PropertyFlags(1)
	model.EntityLastPropertyId(2, 4930178864712545365)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (sourceJobRunID_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*SourceJobRunID).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (sourceJobRunID_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*SourceJobRunID).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (sourceJobRunID_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (sourceJobRunID_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*SourceJobRunID)
	var offsetName = fbutils.CreateStringOffset(fbb, obj.Name)

	// build the FlatBuffers object
	fbb.StartObject(2)
	fbutils.SetUOffsetTSlot(fbb, 0, offsetName)
	fbutils.SetUint64Slot(fbb, 1, id)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (sourceJobRunID_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'SourceJobRunID' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(6, 0)

	return &SourceJobRunID{
		Name: fbutils.GetStringSlot(table, 4),
		Id:   propId,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (sourceJobRunID_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*SourceJobRunID, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (sourceJobRunID_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*SourceJobRunID), nil)
	}
	return append(slice.([]*SourceJobRunID), object.(*SourceJobRunID))
}

// Box provides CRUD access to SourceJobRunID objects
type SourceJobRunIDBox struct {
	*objectbox.Box
}

// BoxForSourceJobRunID opens a box of SourceJobRunID objects
func BoxForSourceJobRunID(ob *objectbox.ObjectBox) *SourceJobRunIDBox {
	return &SourceJobRunIDBox{
		Box: ob.InternalBox(7),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceJobRunID.Id property on the passed object will be assigned the new ID as well.
func (box *SourceJobRunIDBox) Put(object *SourceJobRunID) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceJobRunID.Id property on the passed object will be assigned the new ID as well.
func (box *SourceJobRunIDBox) Insert(object *SourceJobRunID) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *SourceJobRunIDBox) Update(object *SourceJobRunID) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *SourceJobRunIDBox) PutAsync(object *SourceJobRunID) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the SourceJobRunID.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the SourceJobRunID.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *SourceJobRunIDBox) PutMany(objects []*SourceJobRunID) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *SourceJobRunIDBox) Get(id uint64) (*SourceJobRunID, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*SourceJobRunID), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *SourceJobRunIDBox) GetMany(ids ...uint64) ([]*SourceJobRunID, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceJobRunID), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *SourceJobRunIDBox) GetManyExisting(ids ...uint64) ([]*SourceJobRunID, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceJobRunID), nil
}

// GetAll reads all stored objects
func (box *SourceJobRunIDBox) GetAll() ([]*SourceJobRunID, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceJobRunID), nil
}

// Remove deletes a single object
func (box *SourceJobRunIDBox) Remove(object *SourceJobRunID) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *SourceJobRunIDBox) RemoveMany(objects ...*SourceJobRunID) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the SourceJobRunID_ struct to create conditions.
// Keep the *SourceJobRunIDQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *SourceJobRunIDBox) Query(conditions ...objectbox.Condition) *SourceJobRunIDQuery {
	return &SourceJobRunIDQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the SourceJobRunID_ struct to create conditions.
// Keep the *SourceJobRunIDQuery if you intend to execute the query multiple times.
func (box *SourceJobRunIDBox) QueryOrError(conditions ...objectbox.Condition) (*SourceJobRunIDQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &SourceJobRunIDQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See SourceJobRunIDAsyncBox for more information.
func (box *SourceJobRunIDBox) Async() *SourceJobRunIDAsyncBox {
	return &SourceJobRunIDAsyncBox{AsyncBox: box.Box.Async()}
}

// SourceJobRunIDAsyncBox provides asynchronous operations on SourceJobRunID objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type SourceJobRunIDAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForSourceJobRunID creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use SourceJobRunIDBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForSourceJobRunID(ob *objectbox.ObjectBox, timeoutMs uint64) *SourceJobRunIDAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 7, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 7: %s" + err.Error())
	}
	return &SourceJobRunIDAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *SourceJobRunIDAsyncBox) Put(object *SourceJobRunID) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *SourceJobRunIDAsyncBox) Insert(object *SourceJobRunID) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *SourceJobRunIDAsyncBox) Update(object *SourceJobRunID) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *SourceJobRunIDAsyncBox) Remove(object *SourceJobRunID) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all SourceJobRunID which Id is either 42 or 47:
// 		box.Query(SourceJobRunID_.Id.In(42, 47)).Find()
type SourceJobRunIDQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *SourceJobRunIDQuery) Find() ([]*SourceJobRunID, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceJobRunID), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *SourceJobRunIDQuery) Offset(offset uint64) *SourceJobRunIDQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *SourceJobRunIDQuery) Limit(limit uint64) *SourceJobRunIDQuery {
	query.Query.Limit(limit)
	return query
}

type sourceDefinitionID_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var SourceDefinitionIDBinding = sourceDefinitionID_EntityInfo{
	Entity: objectbox.Entity{
		Id: 8,
	},
	Uid: 8782568146941451108,
}

// SourceDefinitionID_ contains type-based Property helpers to facilitate some common operations such as Queries.
var SourceDefinitionID_ = struct {
	Name *objectbox.PropertyString
	Id   *objectbox.PropertyUint64
}{
	Name: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &SourceDefinitionIDBinding.Entity,
		},
	},
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &SourceDefinitionIDBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (sourceDefinitionID_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (sourceDefinitionID_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("SourceDefinitionID", 8, 8782568146941451108)
	model.Property("Name", 9, 1, 2852466399216641482)
	model.PropertyFlags(2080)
	model.PropertyIndex(8, 5976377776647603734)
	model.Property("Id", 6, 2, 8454016484796503646)
	model.PropertyFlags(1)
	model.EntityLastPropertyId(2, 8454016484796503646)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (sourceDefinitionID_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*SourceDefinitionID).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (sourceDefinitionID_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*SourceDefinitionID).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (sourceDefinitionID_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (sourceDefinitionID_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*SourceDefinitionID)
	var offsetName = fbutils.CreateStringOffset(fbb, obj.Name)

	// build the FlatBuffers object
	fbb.StartObject(2)
	fbutils.SetUOffsetTSlot(fbb, 0, offsetName)
	fbutils.SetUint64Slot(fbb, 1, id)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (sourceDefinitionID_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'SourceDefinitionID' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(6, 0)

	return &SourceDefinitionID{
		Name: fbutils.GetStringSlot(table, 4),
		Id:   propId,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (sourceDefinitionID_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*SourceDefinitionID, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (sourceDefinitionID_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*SourceDefinitionID), nil)
	}
	return append(slice.([]*SourceDefinitionID), object.(*SourceDefinitionID))
}

// Box provides CRUD access to SourceDefinitionID objects
type SourceDefinitionIDBox struct {
	*objectbox.Box
}

// BoxForSourceDefinitionID opens a box of SourceDefinitionID objects
func BoxForSourceDefinitionID(ob *objectbox.ObjectBox) *SourceDefinitionIDBox {
	return &SourceDefinitionIDBox{
		Box: ob.InternalBox(8),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceDefinitionID.Id property on the passed object will be assigned the new ID as well.
func (box *SourceDefinitionIDBox) Put(object *SourceDefinitionID) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceDefinitionID.Id property on the passed object will be assigned the new ID as well.
func (box *SourceDefinitionIDBox) Insert(object *SourceDefinitionID) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *SourceDefinitionIDBox) Update(object *SourceDefinitionID) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *SourceDefinitionIDBox) PutAsync(object *SourceDefinitionID) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the SourceDefinitionID.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the SourceDefinitionID.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *SourceDefinitionIDBox) PutMany(objects []*SourceDefinitionID) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *SourceDefinitionIDBox) Get(id uint64) (*SourceDefinitionID, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*SourceDefinitionID), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *SourceDefinitionIDBox) GetMany(ids ...uint64) ([]*SourceDefinitionID, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceDefinitionID), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *SourceDefinitionIDBox) GetManyExisting(ids ...uint64) ([]*SourceDefinitionID, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceDefinitionID), nil
}

// GetAll reads all stored objects
func (box *SourceDefinitionIDBox) GetAll() ([]*SourceDefinitionID, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceDefinitionID), nil
}

// Remove deletes a single object
func (box *SourceDefinitionIDBox) Remove(object *SourceDefinitionID) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *SourceDefinitionIDBox) RemoveMany(objects ...*SourceDefinitionID) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the SourceDefinitionID_ struct to create conditions.
// Keep the *SourceDefinitionIDQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *SourceDefinitionIDBox) Query(conditions ...objectbox.Condition) *SourceDefinitionIDQuery {
	return &SourceDefinitionIDQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the SourceDefinitionID_ struct to create conditions.
// Keep the *SourceDefinitionIDQuery if you intend to execute the query multiple times.
func (box *SourceDefinitionIDBox) QueryOrError(conditions ...objectbox.Condition) (*SourceDefinitionIDQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &SourceDefinitionIDQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See SourceDefinitionIDAsyncBox for more information.
func (box *SourceDefinitionIDBox) Async() *SourceDefinitionIDAsyncBox {
	return &SourceDefinitionIDAsyncBox{AsyncBox: box.Box.Async()}
}

// SourceDefinitionIDAsyncBox provides asynchronous operations on SourceDefinitionID objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type SourceDefinitionIDAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForSourceDefinitionID creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use SourceDefinitionIDBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForSourceDefinitionID(ob *objectbox.ObjectBox, timeoutMs uint64) *SourceDefinitionIDAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 8, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 8: %s" + err.Error())
	}
	return &SourceDefinitionIDAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *SourceDefinitionIDAsyncBox) Put(object *SourceDefinitionID) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *SourceDefinitionIDAsyncBox) Insert(object *SourceDefinitionID) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *SourceDefinitionIDAsyncBox) Update(object *SourceDefinitionID) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *SourceDefinitionIDAsyncBox) Remove(object *SourceDefinitionID) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all SourceDefinitionID which Id is either 42 or 47:
// 		box.Query(SourceDefinitionID_.Id.In(42, 47)).Find()
type SourceDefinitionIDQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *SourceDefinitionIDQuery) Find() ([]*SourceDefinitionID, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceDefinitionID), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *SourceDefinitionIDQuery) Offset(offset uint64) *SourceDefinitionIDQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *SourceDefinitionIDQuery) Limit(limit uint64) *SourceDefinitionIDQuery {
	query.Query.Limit(limit)
	return query
}

type destinationDefinitionID_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var DestinationDefinitionIDBinding = destinationDefinitionID_EntityInfo{
	Entity: objectbox.Entity{
		Id: 9,
	},
	Uid: 2963845346359225551,
}

// DestinationDefinitionID_ contains type-based Property helpers to facilitate some common operations such as Queries.
var DestinationDefinitionID_ = struct {
	Name *objectbox.PropertyString
	Id   *objectbox.PropertyUint64
}{
	Name: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &DestinationDefinitionIDBinding.Entity,
		},
	},
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &DestinationDefinitionIDBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (destinationDefinitionID_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (destinationDefinitionID_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("DestinationDefinitionID", 9, 2963845346359225551)
	model.Property("Name", 9, 1, 5618300392389900923)
	model.PropertyFlags(2080)
	model.PropertyIndex(9, 8620053196703030715)
	model.Property("Id", 6, 2, 3974870246748708097)
	model.PropertyFlags(1)
	model.EntityLastPropertyId(2, 3974870246748708097)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (destinationDefinitionID_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*DestinationDefinitionID).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (destinationDefinitionID_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*DestinationDefinitionID).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (destinationDefinitionID_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (destinationDefinitionID_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*DestinationDefinitionID)
	var offsetName = fbutils.CreateStringOffset(fbb, obj.Name)

	// build the FlatBuffers object
	fbb.StartObject(2)
	fbutils.SetUOffsetTSlot(fbb, 0, offsetName)
	fbutils.SetUint64Slot(fbb, 1, id)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (destinationDefinitionID_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'DestinationDefinitionID' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(6, 0)

	return &DestinationDefinitionID{
		Name: fbutils.GetStringSlot(table, 4),
		Id:   propId,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (destinationDefinitionID_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*DestinationDefinitionID, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (destinationDefinitionID_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*DestinationDefinitionID), nil)
	}
	return append(slice.([]*DestinationDefinitionID), object.(*DestinationDefinitionID))
}

// Box provides CRUD access to DestinationDefinitionID objects
type DestinationDefinitionIDBox struct {
	*objectbox.Box
}

// BoxForDestinationDefinitionID opens a box of DestinationDefinitionID objects
func BoxForDestinationDefinitionID(ob *objectbox.ObjectBox) *DestinationDefinitionIDBox {
	return &DestinationDefinitionIDBox{
		Box: ob.InternalBox(9),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the DestinationDefinitionID.Id property on the passed object will be assigned the new ID as well.
func (box *DestinationDefinitionIDBox) Put(object *DestinationDefinitionID) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the DestinationDefinitionID.Id property on the passed object will be assigned the new ID as well.
func (box *DestinationDefinitionIDBox) Insert(object *DestinationDefinitionID) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *DestinationDefinitionIDBox) Update(object *DestinationDefinitionID) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *DestinationDefinitionIDBox) PutAsync(object *DestinationDefinitionID) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the DestinationDefinitionID.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the DestinationDefinitionID.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *DestinationDefinitionIDBox) PutMany(objects []*DestinationDefinitionID) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *DestinationDefinitionIDBox) Get(id uint64) (*DestinationDefinitionID, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*DestinationDefinitionID), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *DestinationDefinitionIDBox) GetMany(ids ...uint64) ([]*DestinationDefinitionID, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*DestinationDefinitionID), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *DestinationDefinitionIDBox) GetManyExisting(ids ...uint64) ([]*DestinationDefinitionID, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*DestinationDefinitionID), nil
}

// GetAll reads all stored objects
func (box *DestinationDefinitionIDBox) GetAll() ([]*DestinationDefinitionID, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*DestinationDefinitionID), nil
}

// Remove deletes a single object
func (box *DestinationDefinitionIDBox) Remove(object *DestinationDefinitionID) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *DestinationDefinitionIDBox) RemoveMany(objects ...*DestinationDefinitionID) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the DestinationDefinitionID_ struct to create conditions.
// Keep the *DestinationDefinitionIDQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *DestinationDefinitionIDBox) Query(conditions ...objectbox.Condition) *DestinationDefinitionIDQuery {
	return &DestinationDefinitionIDQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the DestinationDefinitionID_ struct to create conditions.
// Keep the *DestinationDefinitionIDQuery if you intend to execute the query multiple times.
func (box *DestinationDefinitionIDBox) QueryOrError(conditions ...objectbox.Condition) (*DestinationDefinitionIDQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &DestinationDefinitionIDQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See DestinationDefinitionIDAsyncBox for more information.
func (box *DestinationDefinitionIDBox) Async() *DestinationDefinitionIDAsyncBox {
	return &DestinationDefinitionIDAsyncBox{AsyncBox: box.Box.Async()}
}

// DestinationDefinitionIDAsyncBox provides asynchronous operations on DestinationDefinitionID objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type DestinationDefinitionIDAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForDestinationDefinitionID creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use DestinationDefinitionIDBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForDestinationDefinitionID(ob *objectbox.ObjectBox, timeoutMs uint64) *DestinationDefinitionIDAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 9, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 9: %s" + err.Error())
	}
	return &DestinationDefinitionIDAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *DestinationDefinitionIDAsyncBox) Put(object *DestinationDefinitionID) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *DestinationDefinitionIDAsyncBox) Insert(object *DestinationDefinitionID) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *DestinationDefinitionIDAsyncBox) Update(object *DestinationDefinitionID) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *DestinationDefinitionIDAsyncBox) Remove(object *DestinationDefinitionID) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all DestinationDefinitionID which Id is either 42 or 47:
// 		box.Query(DestinationDefinitionID_.Id.In(42, 47)).Find()
type DestinationDefinitionIDQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *DestinationDefinitionIDQuery) Find() ([]*DestinationDefinitionID, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*DestinationDefinitionID), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *DestinationDefinitionIDQuery) Offset(offset uint64) *DestinationDefinitionIDQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *DestinationDefinitionIDQuery) Limit(limit uint64) *DestinationDefinitionIDQuery {
	query.Query.Limit(limit)
	return query
}

type sourceCategory_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var SourceCategoryBinding = sourceCategory_EntityInfo{
	Entity: objectbox.Entity{
		Id: 10,
	},
	Uid: 6929600812344984593,
}

// SourceCategory_ contains type-based Property helpers to facilitate some common operations such as Queries.
var SourceCategory_ = struct {
	Name *objectbox.PropertyString
	Id   *objectbox.PropertyUint64
}{
	Name: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &SourceCategoryBinding.Entity,
		},
	},
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &SourceCategoryBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (sourceCategory_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (sourceCategory_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("SourceCategory", 10, 6929600812344984593)
	model.Property("Name", 9, 1, 2828613213349623378)
	model.PropertyFlags(2080)
	model.PropertyIndex(10, 2467731233385356568)
	model.Property("Id", 6, 2, 4359740142348513684)
	model.PropertyFlags(1)
	model.EntityLastPropertyId(2, 4359740142348513684)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (sourceCategory_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*SourceCategory).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (sourceCategory_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*SourceCategory).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (sourceCategory_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (sourceCategory_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*SourceCategory)
	var offsetName = fbutils.CreateStringOffset(fbb, obj.Name)

	// build the FlatBuffers object
	fbb.StartObject(2)
	fbutils.SetUOffsetTSlot(fbb, 0, offsetName)
	fbutils.SetUint64Slot(fbb, 1, id)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (sourceCategory_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'SourceCategory' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(6, 0)

	return &SourceCategory{
		Name: fbutils.GetStringSlot(table, 4),
		Id:   propId,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (sourceCategory_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*SourceCategory, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (sourceCategory_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*SourceCategory), nil)
	}
	return append(slice.([]*SourceCategory), object.(*SourceCategory))
}

// Box provides CRUD access to SourceCategory objects
type SourceCategoryBox struct {
	*objectbox.Box
}

// BoxForSourceCategory opens a box of SourceCategory objects
func BoxForSourceCategory(ob *objectbox.ObjectBox) *SourceCategoryBox {
	return &SourceCategoryBox{
		Box: ob.InternalBox(10),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceCategory.Id property on the passed object will be assigned the new ID as well.
func (box *SourceCategoryBox) Put(object *SourceCategory) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the SourceCategory.Id property on the passed object will be assigned the new ID as well.
func (box *SourceCategoryBox) Insert(object *SourceCategory) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *SourceCategoryBox) Update(object *SourceCategory) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *SourceCategoryBox) PutAsync(object *SourceCategory) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the SourceCategory.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the SourceCategory.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *SourceCategoryBox) PutMany(objects []*SourceCategory) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *SourceCategoryBox) Get(id uint64) (*SourceCategory, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*SourceCategory), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *SourceCategoryBox) GetMany(ids ...uint64) ([]*SourceCategory, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceCategory), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *SourceCategoryBox) GetManyExisting(ids ...uint64) ([]*SourceCategory, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceCategory), nil
}

// GetAll reads all stored objects
func (box *SourceCategoryBox) GetAll() ([]*SourceCategory, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceCategory), nil
}

// Remove deletes a single object
func (box *SourceCategoryBox) Remove(object *SourceCategory) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *SourceCategoryBox) RemoveMany(objects ...*SourceCategory) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the SourceCategory_ struct to create conditions.
// Keep the *SourceCategoryQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *SourceCategoryBox) Query(conditions ...objectbox.Condition) *SourceCategoryQuery {
	return &SourceCategoryQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the SourceCategory_ struct to create conditions.
// Keep the *SourceCategoryQuery if you intend to execute the query multiple times.
func (box *SourceCategoryBox) QueryOrError(conditions ...objectbox.Condition) (*SourceCategoryQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &SourceCategoryQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See SourceCategoryAsyncBox for more information.
func (box *SourceCategoryBox) Async() *SourceCategoryAsyncBox {
	return &SourceCategoryAsyncBox{AsyncBox: box.Box.Async()}
}

// SourceCategoryAsyncBox provides asynchronous operations on SourceCategory objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type SourceCategoryAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForSourceCategory creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use SourceCategoryBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForSourceCategory(ob *objectbox.ObjectBox, timeoutMs uint64) *SourceCategoryAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 10, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 10: %s" + err.Error())
	}
	return &SourceCategoryAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *SourceCategoryAsyncBox) Put(object *SourceCategory) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *SourceCategoryAsyncBox) Insert(object *SourceCategory) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *SourceCategoryAsyncBox) Update(object *SourceCategory) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *SourceCategoryAsyncBox) Remove(object *SourceCategory) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all SourceCategory which Id is either 42 or 47:
// 		box.Query(SourceCategory_.Id.In(42, 47)).Find()
type SourceCategoryQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *SourceCategoryQuery) Find() ([]*SourceCategory, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*SourceCategory), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *SourceCategoryQuery) Offset(offset uint64) *SourceCategoryQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *SourceCategoryQuery) Limit(limit uint64) *SourceCategoryQuery {
	query.Query.Limit(limit)
	return query
}
